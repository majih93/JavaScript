# 4장에서 이어서...var 변수는 왜 문제인가!!!

문제점 요약하자면 3가지가 있어.

- 변수 중복 선언이 가능해 -> 의도치 않게 다시 선언해서 프로그램 실행이 꼬일 수가 있겠지?
- 함수 레벨 스코프 -> 함수를 변경하고 사용할 수 있는 범위가 개발자가 사고하는 블록 단위가 아니라서 잘못 고치거나 사용할 가능성이 있어.
- 변수 호이스팅(이 되면서 동시에 변수가 선언/할당되기 전에 접근해서 사용하는게 가능함.) 코드 순서 상 선언하기 전에 사용하는 코드를 작성해도 사용이 가능하기 때문에 잘못될 여지가 많아져.

# var때문에 스트레스를 많이 받은 개발자들을 위해서 등장한... let, const

사실 이렇게 기술이 개선되어 온 과정을 보면, 이 시대에 개발자로 살고 있는 것에 대해서 감사함을 느낀다.

나는 개발이 재밌는데, 냉정하게 말해서 똑똑하거나 특출난 인간은 아니다. 이렇게 쉽고 편하게 원하는 프로그램을 개발할 수 있는 시대에 태어나서 재밌는 일을 하면서 밥벌어 먹고 살 수 있다는 게 참 감사하다. 나같이 평범한 사람도 노력하면 개발자로 일을 할 수 있는 세상... 좋은 세상이다...

감사함을 가지고 let이 어떤 문제를 어떻게 해결하는지, 사람들은 왜 이제 var을 버리고 let만 쓰는지 알아보자.

변수 중복 선언이 가능해서, 잘못해서 똑같은 이름의 변수를 같은 스코프 내에서 다시 만들어서 의도치 않게 코드가 꼬일 수 있다고 했잖아. 그.래.서....!!!

**let으로 선언된 변수는 동일한 스코프 내에서 동일한 키워드로 변수를 선언할 수 없다고 합니다!!** 이야.... human error의 가능성 자체를 없애버리는게 사실상 가장 안전한데, 그걸 해냈습니다. 일단 벌써부터 좋다.

그리고 스코프가 함수 레벨이라서 변수를 참조할 수 있는 범위가 개발자가 인지하고 있는 범위보다 넓어져버릴 가능성이 존재한다고 했잖아. 그래서 문제생길 소지가 많은데, let은 block레벨 스코프를 가진대. 그래서 개발자가 의도적으로 만들어낸 범위 안에서 변수를 통제할 수 있어서 문제생길 가능성이 훨씬 줄어들었지.

var은 hoisting이 발생하는데, hoisting이 되었을 때 선언하면서 초기화도 같이 진행된다고 했잖아(선언해서 등록하고 초기화를 같이 진행했어.). 그래서 이미 식별자에 연결된 메모리가 있고 undefined가 저장되어 있어서 코드 상에서 실제로 변수 선언부가 등장하기 전에 접근해서 사용이 가능했고, 사람은 만들고 사용한다고 생각하기 마련인데 만들기도 전에 사용이 가능한 구조는 당연히 confusion과 실수를 유발할 가능성이 있었어. 그래서.. let은??

let은 선언과 초기화과 분리되어서 진행 되고, 선언은 평가 시점에 초기화는 런타임에 처리된다.

그렇다는 뜻은?? 변수가 실제 코드 base에서 선언되는 부분에 도달하기 전에는 이 변수에 초기화되어서 할당된 메모리 공간이 없다는 뜻이야. 그러면 그 전에 참조하려고 하면 에러가 발생하고, (ReferenceError) 자연스럽게 실제 변수가 선언된 부분 위쪽에서 접근해서 쓰려는 문제 여지가 있는 코드를 작성할 수가 없어.

근데 그러면 scope안에서 변수의 존재를 엔진이 알긴 하는데 접근은 불가능한 코드의 영역이 있잖아. (예를 들어서 34번째 줄에 선언된 let 변수는 1번째줄부터 33번째 줄까지는 식별자만 등록되어 있고 연결된 공간은 없겠지.) 이 상태가 바로 TDZ.

# let만 보면 서운하니까 const의 장점도 봐야지.

const는 신기한게 선언과 함께 반드시 초기화도 같이 해야된다고 한다.

음 이거에 대해서 명확한 이유나 이런걸 좀 알고 싶은데, 못 찾았다 더 찾아봐야지...

내 생각에는 근데 const 자체의 설계 의도가 재할당이 불가능한 변수를 선언하는 것인데, 만들면서 바로 값을 넣는게 의도적으로도 맞아 보임.

그리고 좀 인상적으로 읽은 부분이, `const 재할당은 안되지만 불변을 의미하지 않는다` 라는 부분이다.

const가 불변이라고 생각하면 const로 선언한 객체의 프로퍼티 변경이 가능하다는 동작방식과 모순되지. 불변이 아니라 새로운 메모리 공간을 연결시키거나 원래 공간에 다른 값으로 교체가 안된다는 것.
