# 변수가 도대체 뭐임

프로그램 - 데이터를 입력받아서 처리하고 출력하는 것이 본질

근데 이 과정에서 데이터를 처리하려면? 어딘가에 저장하고 가져다 쓰고 변경하고 이런 과정이 필요하겠지?

이 때 필요한게 변수야. 그래서 데이터를 관리하는데 가장 기본이 되는 개념이 변수.

데이터를 활용하려면 어떻게 해야될까? 어딘가에 저장을 해야된다.

그리고 저장을 하려면? 컴퓨터는 어떻게 사람이 인식하는 무형의 데이터를 유형의 그 무언가로 저장하고 재활용할 수 있을까?

컴퓨터는 메모리에 값을 2진수 형식으로 저장하고, 필요한 경우 메모리에 있는 값에 접근해서 데이터를 읽어들이고 사용함.

우리는 JavaScript라는 언어를 통해서 프로그래밍을 하는데, 그러면 JavaScript로 프로그램을 작성하려면 JavaScript라는 언어를 사용해서 프로그램에 값을 저장하고 접근해서 값을 불러올 수 있는 메커니즘이 필요하겠지? 그 메커니즘에 가장 기본이 되는 것이 `변수`라는 개념이다.

변수는 값을 저장하기 위해서 확보한 공간, 혹은 그 공간을 식별하기 위해 붙인 이름이라고 한다. 나는 그 공간을 식별하기 위해서 붙인 이름이라는 정의가 더 와닿긴 한다. 아니다 오히려 변수를 정의할 때는 그 공간이고, 그 공간에 이름을 붙여서 다시 사용할 때는 식별하기 위해 붙인 이름이라고 해야될려나...

# 변수 어떻게 만들어? 메커니즘을 어떻게 활용하지?

변수를 만드는 걸 `변수 선언`이라고 함

변수를 `선언`한다는 것에는 몇 가지 작업이 추상화되어서 숨겨져 있는데,

- 값을 저장하고 싶어서 변수를 만드는거잖아 그치. 그래서 값을 저장할 메모리 공간이 확보되고,
- 개발자가 작성한 변수 이름과 확보된 메모리 공간의 주소가 매핑됨. (그래야지 프로그램이 parsing될 때 변수 이름 -> 메모리 주소로 타고 들어가서 값에 접근할 수 있잖아 그치)

좋아 `선언`한다는게 무슨 짓인지는 알겠는데, 그래서 JavaScript에서 그거 어떻게 하는데..

선언하려면 `var`, `let`, `const` 세 가지 중 하나를 써서 선언할 수 있어.

아니 근데 왜 여러개여 헷갈리게. 그냥 하나로 쓰면 안되나?

원래 `var`하나였는데, 이 놈의 특성상 프로그램 작성할 때 개발자들이 겪는 어려움들이 있어서 `es6`에 `let`, `const` 두 친구가 추가되었어. 일단 뭐가 문제였는지 알아야겠지?

# `var`은 왜 더이상 잘 사용되지 않는가? 너는 그 이유를 알고 있니 아니면 그냥 다들 안쓰니까 너도 안쓰니?

나는 사실 다들 안쓰니까 나도 안쓰고, 정확한 이유를 잘 모르고 있다. ㅎ

알아볼까?

일단 공통 사전지식이랄까. 그런게 있어. JavaScript는 변수 선언을 2단계에 걸쳐서 진행한대.

1 - 변수 이름을 등록해서 엔진이 변수가 존재하는 것을 알 수 있게 한 다음에(선언)
2 - 값을 저장하기 위한 메모리 공간을 확보하고 `undefined`를 할당해서 초기화 한다. (초기화)
-> 여기서 좀 궁금할만한 부분은 이런게 있겠지. 아니 근데 왜 굳이 undefined를 넣어서 초기화를 해? 그냥 공간만 연결하면 안되나? 같은 생각이 드는데, 여기에는 어떤 이유가 있냐면, 혹시나 해당 공간이 이전에 사용되어서 남아있었던 값이 있다면 내가 변수에 저장하지 않은 값이 사용될 수 있겠지(garbage라고 하더라구.) 그래서 아예 공간을 한 번 쫙 치워버리는거지. 그냥 호텔방이라고 생각하면 좀 편할 것 같음. 다음 투숙객 오기 전에 안치우면 어떻게 돼 누가 개판치고 갔으면 큰일나지 그래서 항상 정리하고 다음 손님 받잖아. 그런 것처럼 메모리 공간을 undefined를 넣어서 초기화해버려서 항상 동일하게 동작함을 보장할 수 있는거지.

var, let, const 다 기본 동작은 이렇디야.

근데 `var`의 경우에 선언과 초기화가 동시에 이루어진대.

음 그렇구나. 근데 그러면 프로그램이 실행될 때, 변수는 언제 선언될까?

이걸 이해하려면 먼저 JavaScript 프로그램이 어떤 순서로 실행되는지 간략하게라도 알아야 해. JavaScript 엔진은 소스코드를 line by line 실행하기 전에, 먼저 전체 소스코드 평가 과정을 수행함.

평가 -> line by line 실행

그러면 변수 선언은 평가 단계에서 처리될까? 아니면 실행 단계에서 처리될까? -> 정답은 평가단계!!!

아하 그러면 이미 프로그램이 실행되기 전에, 모든 변수가 등록되어있고 메모리 공간도 초기화 되어 있는 거구나.

이게 바로 그 유명한 `hoisting`이야. 변수 선언문이 코드 상 어떤 물리적 위치에 작성되어 있는지 상관없이, 코드 가장 위에서 실행된 것처럼 동작하는 특징(제일 위로 끌려올라와서 실행된 것 처럼 동작한다 이거지.)

사실 이거는 var, let, const 뿐만 아니라 function, class 키워드를 통해서 선언한 다른 식별자들에도 다 동일하게 적용되는 사항이야. 일단 등록해!!! 그리고 코드 실행해.

일단 등록해 그리고 실행해. -> Register first, and then execute!

아니 근데 그건 알겠는데 var 문제가 뭐냐고. (사실 책이 이 문제에 대해서는 15장으로 이어져버려서...별도 문서로 작성하는게 낫겠다.)
-> to be continued..

# 근데 값을 저장하는 건 언제...?

오케이 소스 코드 평가 과정에서 변수가 선언(등록과 초기화) 되는거 알겠음.

그러면 이때 변수에 내가 저장하려고 작성한 값도 같이 저장되나??

NOOOOOOOOO~~~

웃긴게 선언은 평가 단계에서, 할당은 실행 단계에서 런타임에 처리된대... 헷갈리지만 그렇다는데 어쩌겠어.

그러면 변수가 선언되고 거기에 값이 저장되는 과정은 일관된 flow를 타는구나.

변수 등록 -> undefined 초기화 -> 소스 코드 실행 -> 할당문에 도착하면 undefined가 있던 자리에 값 저장.

# 공간 재사용 가능해??

한 번 공간에다가 이름 붙이고 등록한 상태에서, 거기에 값을 저장한 다음에 다른 값을 거기다가 다시 넣는게 가능할까??

var은 된다고 하는데 이 부분은 더 공부가 필요해.

재할당이라고 하는 것이 동작하는 방식에 대해서 잘못 생각한 부분이 있어. 재할당이라고 해서 같은 공간에 있던 값을 치워버리고 새로운 값을 넣는가했는데 그게 아니라,

식별자가 변수에 연결되어 있잖아 그치 근데 식별자에 연결된 변수 공간을 버리고, 새로운 변수 공간을 확보해서 식별자에 새로운 공간을 연결하고 그 공간에 변수를 저장한다.
-> 왜 이렇게 동작하지? 그냥 치워버리고 다시 저장하면 안되나?
-> 이 부분은 좀 찾아보니까, 꼭 그렇게 동작하지 않을 수 있다고 한다. JavaScript 스펙 상 이에 대해서 정해진 부분이 없고, 엔진별로 최적화 여부에 따라서 동일한 공간을 재사용할 수도 있다고는 하는데 더 공부가 필요함...(히히)
