# 실행 컨텍스트로 왜 갑자기 뛰어왔을까...

JavaScript 공부를 시작하겠다고 마음 먹은 이유가 React Query 문서 읽다가 JavaScript 비동기 코드가 이해가 안되는 부분들이 있어서 그랬음.

근래에 HTTP나, Spring Boot와 React를 같이 사용하는 방법 등을 공부할 일이 계속 생길 가능성이 커서 비동기 관련 공부부터 하고 다른 공부를 하려고 함.

# 실행 컨텍스트가 뭐야???

JavaScript 소스 코드는 4가지 종류의 코드에 따라서 각각 다른 실행 컨텍스트가 생성된다고 함.

전역코드 -> 전역 실행 컨텍스트
함수코드 -> 함수 실행 컨텍스트
eval 코드 -> eval 실행 컨텍스트
모듈 코드 -> 모듈 실행 컨텍스트

뭔가 코드에 대해서 실행 컨텍스트라는게 생성되는 것은 알겠음.

이 실행 컨텍스트는 소스코드의 평가로 인해서 생성된 것. 소스코드를 실행하는데 필요한 정보를 저장해둔 저장소 느낌으로 이해가 된다.

소스코드 평가 과정에서 실행 컨텍스트가 생성되고(변수 등 식별자 등록하는 작업이 이때 처리 됨.) 소스코드 실행 과정에서 실행 컨텍스트에 등록된 변수 등에 대한 참조를 실행 컨텍스트가 관리하는 스코프에서 검색해서 취득한다. (스코프에서 검색해서 취득이라는게 조금 이해가 바로 되지는 않음.)

정확하게는 모르지만 실행 컨텍스트가 관리하는 전역 스코프가 존재하고, 전역 객체가 있어서 전역 변수와 함수는 해당 객체의 프로퍼티와 메서드로 등록된다.

함수가 실행되면 함수도 실행 컨텍스트의 지역 스코프에 함수 매개변수와 지역 변수가 등록된다고 한다.

뭔지 정확하게 모르겠지만 실행 컨텍스트가 약간 좀 관리자 같은 느낌이라는 생각이 든다.

이런 순서로 이해가 되어야하는게 맞는 것 같다.

JavaScript 코드를 실행하려면 뭐가 필요할까?

변수가 선언되어야 하고, 함수를 실행할 수 있어야 한다.
근데 변수와 함수를 제대로 실행하려면

- 변수에 어떤 값이 저장되어 있는지 알 수 있어야 하고,
- 값의 변화가 해당 변수에 연관해서 잘 관리되어야 하고,
- 값이 속한 범위에서 잘 가져와서 실행되어야 한다. 예를 들어서, 동일한 이름의 변수가 서로 다른 스코프에 존재한다면 어떤 스코프에서 참조될 때 가져와야하는지 알 수 있어야 한다.
- 코드 실행 순서가 개발자의 의도대로 진행되도록 해야 한다. (왔다리갔다리 하면서 실행되는 상황에서 이전으로 돌아갔다가 다시 실행 시점으로 돌아올 수 있어야 한다.)

이런거 하나하나 처리하려면 뭔가 그걸 관리하는 메커니즘이 필요하고, 이걸 관리하는 주체가 실행 컨텍스트임.

실행 컨텍스트는

- 소스코드 실행하는데 필요한 환경을 제공(스코프 체인이라던지, 스코프별로 등록되어 있는 메서드와 프로퍼티 등)
- 코드의 실행 결과 관리(변수 변화 과정 추적, 실행 위치 관리 등..)

식별자와 스코프 -> `렉시컬 환경` 으로 관리
코드 실행 순서 -> `실행 컨텍스트 스택`으로 관리

AHA!! 렉시컬 환경이나 스택이나 이런 표현들이 이거랑 상관이 있구나.

뭔가 코드 실행에 필요한 것들을 총괄하는 주체가 필요하고, 그 주체는 2가지 방법으로 각각 역할을 수행한다.

# 실행 컨텍스트 구성요소 첫 번째 - 실행 컨텍스트 스택

코드 실행 순서를 관리하는 스택부터 알아보자.

스택은 뭐야? push/pop을 통해서 들어온 순서대로 데이터를 처리하기 위한 자료구조임. 나중에 들어온 친구를 먼저 처리하는 구조이고, 들어온 순서대로 자료를 기억하고 있음.

실행 컨텍스트 스택은 말 그대로 실행 컨텍스트를 생성된 순서대로 담고 있음.

일단 코드 시작점은 전역 코드잖아 그치

Stack: [전역 실행 컨텍스트]

이 상태에서, 함수가 실행되면 함수 실행에 필요한 해당 함수 실행 컨텍스트가 실행된다.

Stack: [전역 실행 컨텍스트, 함수 실행 컨텍스트]

이 상태에서 실행 컨텍스트에는 지역변수 등이 등록되어 있다.

그리고 함수 실행이 완료되면 Stack에서 함수 실행 컨텍스트가 pop되고, 마지막으로 더 실행할 코드가 없으면 전역 실행 컨텍스트도 pop되어서 프로그램 실행이 종료된다.

이 구조로 코드 실행 순서를 관리하려면 Stack의 top인 실행 컨텍스트는 항상 현재 실행 중인 코드의 실행 컨텍스트이다.

오홍 이렇게 코드 실행 순서와, 실행에 필요한 데이터가 관리되고 있는 거구나.

# 실행 컨텍스트 구성요소 두 번째 - 렉시컬 환경

식별자, 식별자에 바인딩된 값, 상위 스코프(스코프 체인)에 대한 참조가 기록되어 있는 자료구조.

깊게 들어가면 더 다른 요소들이 있지만 간단하게 분류하면

- EnvironmentRecord: 식별자와 바인딩된 값
- OuterLexicalEnvironmentReference: 상위 스코프에 대한 참조

2가지로 구성된다.

아래 코드에 대해서 내가 공부하고 이해한 내용을 토대로 어떤 작업이 수행되는지 먼저 생각해보고 책이랑 대조해보자.

```javascript
var x = 1;
const y = 2;

function foo(a) {
  var x = 3;
  const y = 4;

  function bar(b) {
    const z = 5;
    console.log(a + b + x + y + z);
  }

  bar(10);
}

foo(20);
```

일단 프로그램을 실행하기 위해서 JavaScript 엔진은 어떤 작업을 어떤 순서로 실행하는가?

소스코드 평가 -> 실행 순서로 진행된다.

소스코드를 평가해서 실행 컨텍스트를 생성하고, 필요한 변수들을 등록해서 실행 과정에서 검색해서 사용하고

실행하는 과정에서 실행 컨텍스트 스택에 순서대로 영역별 실행 컨텍스트들을 넣고 빼면서 프로그램 실행 순서를 조절이라고 이해하고 있음.

프로그램이 처리되는 순서: 평가 -> 실행
처리하는 방법: 실행 컨텍스트 스택과 렉시컬 환경을 조합해서 변수를 등록해서 관리하고 사용하면서 순서대로 처리

자 그럼 순서를 한 번 생각해볼까.

1. [평가]소스코드 평가 시작

2. [평가]전역 코드에 대해서 전역 실행 컨텍스트 생성

3. [평가]x, y, function foo가 전역 실행 컨텍스트의 EnvRecord에 등록됨.

4. [실행]평가 단계가 끝나고, 실행 컨텍스트 스택에 전역 실행 컨텍스가 push 되어서 프로그램 시작 런타임 ㄱㄱ

5. [실행]막 프로그램이 실행 돼. 변수에 실제로 값이 할당되고

6. [실행]함수를 실행하는 foo()에 도착하면 함수 코드에 의해서 함수 실행 컨텍스트가 생성된다.

7. [실행]foo의 코드를 평가해서 함수 실행 컨텍스트의 렉시컬 환경의 EnvRecord에 x, y, bar가 등록되고, OuterLexicalEnvironmentReference에 상위 스코프인 전역 실행 컨텍스트의ㅏ 렉시컬 환경에 대한 참조가 저장됨

8. [실행]foo 함수 실행 컨텍스트가 생성된 다음에, 실행 컨텍스트 스택에 push 되어서 코드가 실행되는 동안 유지된다.

9. [실행]마찬가지로 bar에 대해서도 컨텍스트 만들고, 변수+바인딩값 등록하고, 상위 스코프인 foo함수 렉시컬 환경에 대한 참조 연결하는 프로세스에 이어서 bar 함수 실행 컨텍스트가 Stack에 쌓여서 top이 되어서 실행

10. [실행]bar함수의 실행이 종료되면 ECS에서 pop되고, 코드 제어권이 다시 top인 foo함수의 실행 컨텍스트로 넘어감

11. [실행]이런 식으로 실행이 완료된 다음에 전역 실행 컨텍스트도 pop되어서 최종 종료..

실행하는 과정에서 특정 변수를 참조하면, 먼저 자신이 속해있는 실행 컨텍스트의 렉시컬 환경을 검색 -> 값이 있으면 사용하고 없으면 LexicalEnvironment의 OuterLexicalEnvironmentReference에 저장된 상위 스코프의 렉시컬 환경에 대한 참조를 타고 들어가서 거기서 검색하면서 타고 올라가서 전역까지 가는 식으로 동작한다!!

---

이게 개념들이 너무 서로 헷갈리고 위계 구조 같은게 잘 안잡힌다.

[글로벌]

실행 컨텍스트

- 렉시컬 환경

  - 환경 레코드
    - 객체 환경 레코드
      - var, function 키워드 요소들 등록
      - BindingObject
    - 선언적 환경 레코드
      - let, const로 생성된 식별자 등록 및 관리
      - 등록은 평가 단계에서 처리되지만, 초기화가 되지 않은 상태에서 선언적 환경 레코드에만 등록되어 있는 상태(코드 평가 시점 ~ 변수 선언(const는 선언+할당) 시점)를 TDZ에 빠져있다고 한다.
    - this 바인딩
      - this 바인딩은 전역 환경 레코드와 함수 환경 레코드에만 존재(객체 환경 레코드와 선언적 환경 레코드에는 존재하지 않음)
      - 전역 환경 레코드의 [[GlobalThisValue]] 내부 슬롯에 this가 바인딩. 보통 전역 코드에서 this는 전역 객체를 가리킨다.
  - 외부 렉시컬 환경에 대한 참조
  - 전역 렉시컬 환경의 경우 상위 렉시컬 환경이 없으므로 OuterLexicalEnvironmentReference에 null이 할당(스코프 체인의 종료)

  여기까지 처리되면 이제 실행단계로 넘어간다.

foo 함수가 호출되면 발생하는 일

- 전역 코드 실행 중단 foo함수 내부로 코드 제어권 이동 후 평가 시작
- 함수 실행 컨텍스트
  - 함수 렉시컬 환경
    - 함수 환경 레코드
      - 매개변수, arguments객체 등등을 등록과 관리
    - this 바인딩
      - [[ThisValue]] 내부 슬롯에 this가 바인딩 됨. 런타임에 동적으로 결정된다는게 이거와 연관이 있구나. 런타임에 함수 호출 시 평가되는 컨텍스트 안에서 this가 결정되기 때문에 그때그때 다를 수 있음.
  - 외부 렉시컬 환경에 대한 참조 결정
    - this와 비슷하게 평가된 시점에 실행 중인(실행 컨텍스트 stack의 top인 실행 컨텍스트) 컨텍스트의 렉시컬 환경의 참조가 할당.

JavaScript는 함수를 어디서 호출했는지가 아니라 어디에 정의했는지에 따라서 상위 스코프가 결정됨.

함수 정의를 평가해서 함수 객체를 생성할 때 현재 실행 중인 실행 컨텍스트의 렉시컬 환경(함수 입장에서는 상위 스코프임)을 [[Environment]] 내부 슬롯에 저장한다.

함수 렉시컬 환경의 함수 환경 레코드의 OuterLexicalEnvironmentReference에 저장되는 것은 바로 이 참조값.

호출되는 지점과 상위 스코프가 관계가 없는 이유는 JavaScript에서는 함수의 상위 스코프가 함수 정의가 평가되는 시점에 결정되기 때문이다.(함수 객체가 생성되면서 상위 스코프로 함수 정의를 평가하는 시점에 실행되고 있는 실행 컨텍스트의 렉시컬 환경이 [[Environment]] 내부 슬롯에 등록) -> 이후에 어디서 호출하건 상관이 없다.

근데 이해가 되지 않는 점이 하나가 있는데 이것만 clear하게 하고 가면 오늘은 될 것 같다.

함수 정의가 평가되는 것도 근데 함수가 호출된 시점이면, 호출된 실행 컨텍스트와 정의된 코드가 위치한 실행 컨텍스트가 다르면 어떻게 되는거야? 아니면 정의가 평가되는 시점은 다른 시점인가?

정의가 평가되는 것은 소스코드 평가 시점에서 다 처리되나 중첩함수도? 이걸 알아야지 제대로 이해가 될 것 같음.

# 소스코드는 한 번만 평가되고 끝나는게 아니다.

소스코드가 최초 한 번만 평가되고 그 뒤는 실행만 되는게 아니라,

전역 객체의 함수가 호출되면 -> 함수 코드 안으로 제어권 이동하고 함수 안에 존재하는 함수가 있다면 그 함수에 대한 객체 생성 및 등록(이 때 상위 스코프에 대한 참조가 저장됨.) 호출될 때 기록되는게 아니라 함수 정의가 평가될 때 기록되는 것이기 때문에 호출이 어디서 얼마나 되는것과 관계 없이 동일한 상위 스코프에 대한 참조를 가지고 있음.

이런 관점에서 closure에 대해서 생각해보니까 좀 더 이해가 되는 부분이 있다.
