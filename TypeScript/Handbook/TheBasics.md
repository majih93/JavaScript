[Handbook - The Basics](https://www.typescriptlang.org/ko/docs/handbook/2/basic-types.html)

JavaScript에서는 코드 실행 전에 해당 코드가 잘 동작할 것인지 예측하기가 어렵다.

전달된 값이 이슈가 있어서 실행에 문제가 있다고 해도, 이런 에러를 실제 실행해봐야지 알 수 있음.
-> 바꿔 말하면, 코드를 작성하는 시점에 코드가 어떤 결과를 보일지 알기가 어렵다.

이에 대한 대안은 정적 타입 시스템을 사용해서 코드 실행 전에 실행 결과를 예측하는 것이다.

정적 타입 시스템을 도입함으로써 때로는 표현의 유연성을 잃을 수는 있다. 하지만 잃는 것보다 얻는 것이 크다고 판단한 것.

그런데, 재미있는 포인트가 있네.

`tsc`를 활용해서 `.ts` 파일을 `.js`파일로 변환 시, 파일 내에 TypeError가 있어도 변환을 시도하면 변환 자체는 된다.

이에 깔려있는 아이디어는, 사용자가 이에 대해서 더 잘 알것이라는 생각이라고 함. (TypeScript보다 내가 더 내가 뭘 하려는지 잘 알고 있으리라는 생각.)
-> 음...ㅋㅋㅋㅋㅋ 안그런 경우도 분명히 많을텐데... 잘 알고 써야하는구나라는 생각이 많이 들기도 한다.

TypeScript상에서는 문제가 있지만, JavaScript 코드 자체는 에러없이 잘 수행되는 경우가 많다. 이 경우 TypeScript에서 문제가 있다고 해서 실행이 안되거나 할 필요는 없다.
-> `타입 표기는 프로그램의 런타임 동작을 전혀 수정하지 않는다.`

만약에 TS에서 에러가 발생한 경우 컴파일된 JS파일을 생성하지 않으려면, 아래와 같이 `--noEmitOnError` 옵션을 주면 된다.

```
tsc --noEmitOnError hello.ts
```

TS는 상황에 따라서 데이터 타입을 추론할 수 있다. 문서에서는 이런 경우 굳이 타입을 명시하지 않는게 낫다고 주장한다.

### 다운레벨링

`새로운 또는 “상위” 버전의 ECMAScript를 예전의 또는 “하위” 버전의 것으로 바꾸는 과정을 다운레벨링이라 부르기도 합니다.`

ES5로 작성된 코드를, 보다 낮은 버전의 ES코드로 변환해준다.

`--target`옵션을 컴파일 시 추가해서 특정 버전의 ES코드로 변환하는 것도 가능하다.

### 엄격도

TS는 사용자의 목적에 따라서 다른 수준의 엄격도를 가지고 코드를 검사할 수 있음.

몇 가지 on/off가 가능한 옵션들이 제공되는데, 주로 알아야하는 것은 다음 2가지.

**noImplicitAny**

암묵적으로 any로 추론되는 변수에 대해서 에러발생시킴

**strictNullChecks**

null/undefined 관련해서 처리를 보다 명시적으로 만들어줘서 이와 관련된 에러를 방지함.
