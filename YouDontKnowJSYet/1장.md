# 1장

> 자바와 자바스크립트의 관계는 햄과 햄스터의 관계와 같습니다.

하하하.

## 1.3 명세서

**TC39 - JS를 관리하는 기술 운영 위원회**

- 여기서 명세 변경 안건 투표하고, 합의된 사항을 국제 표준화 기구인 ECMA에 제출. 이 명세에 JS문법과 작동 방식이 결정된다.
- 모든 제안은 0~4까지 5단계를 거친다. (여기서도 0 기반 인덱싱이라니... 개발자들이란.)
  - 모든 제안은 [깃허브](https://github.com/tc39/proposals)에서 확인 가능.
- 엄밀하게 말하면 JS는 버전이 없다. 오직 `현 단계의 표준` 하나가 있을 뿐.
  - 단일화된 명세서를 기준으로 JS구현체를 만들어야 함. 즉, 브라우저로 따지면 V8엔진에서 되는 기능이 스파이더멍키(모질라)엔진과 동작이 다르면 안됨.
  - 이것이 보장된다는 전제가 있기 때문에 우리는 `단 하나의 JS`만 배우면 된다.

**가급적 특정 JS엔진에 종속되지 않으면서 명세서를 준수하는 구현체만 사용하자**

다양한 웹브라우저들이 오랜 시간동안 개발되어 왔고, 그동안 JS도 몇 번의 개정이 이루어졌다. 그 과정에서 불일치들이나, 웹환경에서만 사용되고 명세에는 등재되지 않은 기능들이 존재한다. 이런 점에 대해서 인지만 하고, 개발할 때는 최대한 이런 부분을 피해서 global하게 문제가 없는 코드를 작성해야된다고 이해했다.

**JS처럼 보이는데 JS가 아닌 문법**

아래 기능들은 우리가 흔히 JS라고 인식하지만 아니다.(엄밀히 말하자면 명세서에 없다.)

- `console` 함수들
- `alert()`
- `fetch()`

JS의 함수와 객체 메서드 규칙을 따르고 JS처럼 보이지만, 따로 구현된 커스텀 API라고 보면 된다.

내가 함수를 정의해서 재사용하는 것처럼, 브라우저 환경이나 Node.js 환경에서 각 환경이 사용자 편의를 위해 추가한 커스텀 메서드나 기능이라고 이해된다.

**하위 호환성**

JS는 계속 변해왔지만, 그 과정에서 `하위 호환성`을 보장하고 있다. 개발자는 이에 따른 이점, 제약, 어려움을 알고 있어야 한다.

`하위 호환성`: 단 한 번이라도 유효한 JS 문법이라고 인저오디면 명세서가 변경되더라도 절대 그 유효성이 깨지지 않음을 의미.

이 `하위 호환성` 덕분에 옛날에 작성한 코드도 시간이 흘러도 깨지지 않고 동작함을 보장받을 수 있음.

드물게 `하위 호환성`에 위배되는 의사 결정이 있지만, 사용자가 눈치채지 못할 부분에 영향을 주는 범위에서 처리하려고 최대한 노력한다.

**상위 호환성**

`상위 호환성`을 갖췄다고 하면, 새롭게 추가된 JS를 구형 JS엔진에서 돌렸을 때 문제가 발생하지 않아야 한다.

하지만 JS는 `상위 호환성`을 보장하는 언어가 아니다.

실행환경에서 이해할 수 없는 부분을 건너뛰고 실행할 때 크리티컬한 프로그래밍 언어의 특성 상, `상위 호환성`을 보장하는 것은 비현실적 목표. (HTML, CSS는 상위 호환성이 보장되고 반대로 하위 호환성이 보장되지 않는다. 과거에 작성된 HTML/CSS 코드가 지금 동작하지 않을 수는 있지만, 옛날 브라우저에서 최신 HTML/CSS를 사용한다고 해서 웹페이지가 망가지지는 않는다. )

**그러면 옛날 브라우저에서 기능 안돌아가니까 계속 옛날 기능만 써야하나!!**

이런 생각이 자연스레 든다. 하지만 다행스럽게도 아니다.

이 간극을 줄이기 위한 다양한 노력들이 있어왔고, 너가 그 덕분에 최신 JS문법으로 꿀을 빨고 있는거란다.

여기서 바로 바벨같은 `transpiler`의 필요성이 등장한다.

구 엔진과 호환되지 않는 문법이 문제없이 돌아가도록 transpiler를 통해서 호환되는 형태로 변경해서 실행하는 방식으로 해결할 수 있다.

**폴리필!! polyfill**

마침 최근에 폴리필이 뭐지 하는 생각을 했었는데 이 책에 이렇게 등장하는구나.

특정 실행환경에서 근래에 추가되었는데 아직 지원하지 않는 API 메서드 때문에 특정 이슈가 발생했다면, 메서드 정의를 추가해서 이미 이 환경에 존재했던 것처럼 만들어주는 것이 가장 일반적인 해결책이다.

이런 방법을 바로 `polyfill`이라고 한다.

바벨과 같은 트랜스파일러는 폴리필이 필요한 코드를 찾아 자동으로 폴리필을 추가한다. 경우에 따라서는 개발자가 직접 폴리필을 추가해야 한다.

트랜스파일/폴리필은 계속 진화하는 JS와 과거의 애플리케이션이나 실행 환경 사이를 연결해주는 역할을 한다.

**인터프리터**

JS가 인터프리터 언어인지, 컴파일러 언어인지는 논쟁의 대상이다.

JS가 어디에 속하는지 명확하게 알고 있는 것은 중요하다. 그래야지 JS가 오류를 처리하는 방식을 알 수 있기 때문이다.

스크립트 언어/인터프리터 언어 대체적으로 위에서 아래로 코드를 한 줄씩 실행하는 형태로 만들어진다. 그리고 보통 실행이 시작되기 전에 거치는 사전 단계가 없다.

코드를 한 줄씩 실행하고, 실행 전처리 단계가 없으므로 4번째 줄까지는 잘 실행되고 5번째 줄에서 에러가 발생할 수 있다.

반대로 실행 전에 파싱이라는 전처리 단계를 거치는 언어도 있다.

`파싱 -> 컴파일 -> 실행` 단계를 통해 실행되므로, 파싱 단계에서 구문 오류(정적 오류라고도 함)을 차단할 가능성이 높다.

모든 컴파일 언어는 파싱을 거친다. 파싱이 끝난 후에 일이 다 끝나는게 아니라, 파싱의 결과를 컴퓨터가 실행할 수 있는 형태로 변경하는 작업이 이어진다. 파싱을 거치는 언어는 결과적으로 이 컴퓨터가 실행할 수 있는 형태로 변환하는 작업까지 이어지므로 파싱을 거치는 언어는 컴파일 언어라고 통용된다. (물을 끓이면 라면을 넣듯이 파싱을 하면 컴파일도 한다. 같은 느낌이군.)

JS 소스 코드는 실행 전에 파싱 단계를 거친다. 그러면 위 논리대로라면 JS는 컴파일 언어라고 봐야하는데, 맞을까?

답은.....`아니오 보다는 예에 가깝다` 라고 한다.

JS에서 파싱이 끝난 코드는 컴파일러를 통해 최적화된 이진 코드 형태로 변환되어 실행된다. (일반적인 컴파일 언어가 실행되기까지의 프로세스와 비슷하다.)

**JS의 컴파일 단계에서는 무슨 일이..?**

컴파일 단계에서는 JS 가상 머신에 전달할 이진 바이트 코드가 생성된다.

JS엔진은 파싱 이후 생성된 코드를 다양한 방법으로 실행 전에 그때그때(JIT, Just-In-Time) 처리 및 최적화 한다.

이런 동작 방식 때문에 관점에 따라서 인터프리터 언어라고 볼 수도 있고, 컴파일 언어라고도 할 수 있다.

- 파싱 -> 컴파일을 통해 실행 파일을 생성해서 실행한다는 관점에서 컴파일 언어.
- 실행단계에서 즉각적으로 처리 및 최적화가 된다는 점에서 인터프리터 언어.

JS 소스코드가 실행되는 과정은 다음과 같다.

- 코드가 트랜스파일된 이후 웹팩같은 번들러에 의해 번들링되어 그 결과가 JS엔진에 전달.
  -> JS엔진은 코드를 파싱해 추상 구문 트리로 변경
  -> 이어서 추상 구문 트리를 이진 바이트 코드로 바꾼다. 이 과정에서 JIT컴파일러가 작동하며 최적화 진행
  -> JS 가상 머신이 프로그램을 실행

책을 쓴 사람은 컴파일 언어라고 생각한다고 한다.

컴파일 언어라는 점은 왜 중요한지? 개발자가 문법 오류 등을 저질러도 실행 전 정적 오류를 발견할 수 있다는 점 때문이다. 다른 스크립트 언어 대비 다른 방식, 더 나은 방식으로 개발이 가능하다는 의미.

`JS는 컴파일 처리되는 언어이다. 그렇기 때문에 실행 전에 코드를 점검하고 오류가 있을 때 보고된다..`

**웹어셈블리**

Web assembly, aka Wasm

Wasm의 목적은 JS가 주력 언어가 아닌 개발자도 JS엔진에서 돌아가는 코드를 쉽게 작성할 수 있게 하는데 그 목적이 있다.

하지만 파싱과 컴파일을 거치지 않는다.(즉 그 시간만큼의 지연이 없음)

Wasm은 성능 향상을 위해서 만들어졌다.

Wasm을 통해서 다른 언어로 작성된 프로그램을 JS엔진에서 돌릴 수 있다면, 다른 언어에서 제공하는 기능을 JS에도 도입해야 된다는 압박이 줄어든다.

Wasm은 정적 타입 정보에 크게 의존(이를 통해 성능 향상)하므로, JS는 아이러니 하게도 Wasm 프로그램 구현에 가장 적합하지 않은 언어이다.

Wasm의 등장으로 JS가 사라질 위기에 처했느냐? 전혀 아니다. Wasm은 웹에서 할 수 있는 것들을 확장하는 역할을 한다.

**use strict, 엄격 모드**

`엄격 모드`란 뭘 못하게 하는 모드가 아니다. 제약이 아니라, JS엔진이 코드를 최적화하고 효율적으로 실행할 수 있게 해주는 최고의 `안내 가이드 역할 모드`이다.

`엄격 모드`에서 활성화되는 대부분의 가이드는 구문 오류는 아니지만 컴파일 단계에서 잡힐만한 오류들이다.

전처리 구문 `"use strict";`가 있는 경우 활성화 되고, 이 구문 앞에는 주석/공백 이외의 문자는 허용되지 않는다. 혹시 앞에 뭐라도 하나가 있으면 활성화 되지 않으니 주의하자.

`엄격 모드`는 파일 단위 뿐만 아니라 함수 단위에서도 적용할 수 있다.

```javascript
// 함수 단위 엄격 모드와 파일 단위 엄격 모드 중 하나만 사용할 수 있다.
function someOperation() {
  // 이곳에 공백주석 외의 뭔가 있다면 활성화되지 않는다.
  "use strict";
}
```

앞서 언급한 기존 코드도 동일하게 동작함을 보장하는 이슈 때문에 엄격 모드를 기본으로 정착시키기에는 어려움이 있다.

다만 ES6 모듈 형식으로 만든 파일은 자동으로 엄격 모드를 준수한다.
