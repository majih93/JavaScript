# 2장

학습목표: 진정한 JS를 느끼고 자신 있게 코드를 작성할 수 있는 지식을 습득한다.

빨리 읽으려고 하지말고, 천천히 잘 씹어 먹어야 하는 장이다.

각 절에서 다루는 주제를 숙고하고 탐구해봐라.

## 2.1 파일은 프로그램이다.

이게 무슨 소리인고 하니, 하나의 `.js`파일이 하나의 프로그램이라는 의미이다.

애플리케이션 관점에서는 하나의 거대한 프로그램을 사용하는 것처럼 생각되지만, 이는 개별 JS프로그램(파일)들이 협력해 하나의 프로그램처럼 동작하는 것처럼 보이는 것 뿐이다.

독립적인 `.js`파일 여러 개를 하나의 프로그램으로 실행하는 유일한 방법은 `전역 스코프`를 사용해서 파일 간 상태를 공유하고, 공통으로 사용하는 기능을 조합할 수 있도록 만드는 방법 뿐이다. 전역 스코프 네임스페이스에서 여러 `.js`파일이 조합되면 런타임에서 하나의 어플리케이션으로서 작동한다.

파일 하나를 `고유한 작은 프로그램`이라고 생각하는 것부터 접근의 시작이다.

## 2.2 값

`Value`.

프로그램에서 정보의 가장 기본적인 단위.

`값`에 `데이터`가 저장된다. `값`이 있기 때문에 프로그램은 `상태`를 유지할 수 있다.

JS에서는 크게 `원시 타입`과 `객체 타입`으로 분류된다.

JS에서는 `리터럴`을 사용해서 프로그램에 값을 주입한다.

`null`, `undefined`도 원시 값이라는 점. 그리고 두 값이 모두 값의 부재를 나타내는데 사용된다. 중요한 것은 일관성 있는 사용이다.

**값의 타입**

```javascript
typeof null; // object -> 버그임.
typeof function hello() {}; // function
typeof []; // object. 배열은 object로 반환된다는 점. JavaScript의 배열은 배열의 방식으로 사용할 수 있는 특수 객체라고 했던 것과 연결되어 있을까? 맞다. 언어의 타입 시스템 관점에서는 여전히 '객체'이다.
```

## 2.3 변수 선언과 사용

`var` - 함수 스코프, 함수 내부에서 선언 시 선언된 함수 내부에서만 사용, 함수가 아닌 곳에서 선언 시 전역변수로 동작.
`let` - 블록 스코프

`var`로 변수를 선언하는 것도 필요한 경우가 있을 수 있다.

`var는 뭔지 모르지만 나쁘고, 무조건 let/const를 사용해라`라고 생각하는 것은 JavaScript지식의 부족함을 드러내는 것이 아닐까 하는 생각이 든다.

`var`의 특성을 이해하고 사용되어야 하는 순간이 있다면 적절하게 사용할 수는 있어야 한다. 정말 `var`의 기능이 필요하다면, 요즘 같이 `var`를 쓰면 거의 죄를 짓는 것처럼 생각되는 시대에는 이에 대해서 적절한 주석을 작성하면 좋을 것 같다.

**`const`를 이용해서 객체를 선언하지 마라**

필자는 `const`는 의미 상 재할당이 안되는 값이라는 측면에서, `const`로 만든 객체의 값을 바꿀 수 있기 때문에 혼란을 야기할 수 있다고 주장한다.

그런데 이거는 조금... 동의가 어려운 부분인데 이거는 내가 그동안 흔하게 `const`를 활용해서 객체/배열을 선언해서 사용해왔기 때문일까?

관련해서 구글링을 좀 해본 결과...

- AirBnB JavaScript 스타일에서는 `const`로 선언하고, 배열/객체 자체를 재할당 하고 싶은 경우에만 `let`을 사용하라고 한다
- Stackoverflow에 비슷한 질문에 대한 답들을 보니 대체적으로 재할당하지 않는 객체/배열값의 경우 `const`로 선언하는 것이 일반적인 것으로 보인다.

내 생각에는 이 또한 필자의 의견 정도로 이해하면 될 것 같다. 다만, `const로` 객체/배열을 선언하는 것과, `let`으로 선언하는 것의 차이점을 알고 있으면 된다.

**`function` 키워드가 스코프 측면에서 `var`키워드 처럼 동작한다는점..!**

전역에 선언된 함수는 전역 변수처럼, 함수 내에서 선언된 다른 함수는 선언된 함수를 스코프로 가진다. 그르네!

## 2.4 함수

함수 선언문 형태로 선언된 함수는, 컴파일 단계에서 식별자와 함수 값이 연결된다. 아하! 그래서 `function` 키워드로 선언된 함수는 함수 선언문이 등장하기 전에 호출이 가능하구나. 컴파일 단계에서 이미 환경에 등록이 되어있으니까.

반대로, 함수 표현식 형태로 선언된 함수는 식별자와 함수 값이 코드가 실행되어서 `평가`되어야 연결된다는 점이다. 그래서 `const someFunc = function() {}`와 같이 함수 표현식 형태로 정의된 함수는 함수가 초기화되기 전에 사용할 수 없다.
(함수가 호이스팅은 되지만, 초기화는 되지 않은 상태이기 때문에 `Cannot access before initialization`에러 발생한다. TDZ(temporal dead zone)에 있는 상태)

## 2.5 비교

### 2.5.1 같다라는 것은 뭘까? `같음`에 대한 고찰

오.. 그치 이게 맞지. `같은지` 비교한다고 하면, 우선 두 값이 서로 어떤 관계일 때 `같다`라고 할 것인지 부터 정의해야지.

아 이런거 좋다. 이런게 공감되는게 뭔가 나도 개발자가 되어가는 느낌이 조금 있어서 좋음.

JS에서 같음을 비교할 때는 두 값이 서로 정확하게 일치하는지를 따질 때도 있지만, `아주 유사하다` 라던지, `교환 가능하다`라던지 하는 더 넓은 범위의 비교가 실행되는 경우도 있다.

그래서 `일치비교 - equality comparison`과 `동등비교 - equivalence comparison`의 차이를 알아야 한다.

오... `equality` vs `equivalence`라고 영어 단어로 하니 더 와닿는다. 똑같은지? 아니면 서로 동등한지는 확실히 다른 문제지.

**객체끼리 비교할 때는 `독자성 일치`를 비교한다.**

다르게 말하면, `참조`를 기준으로 비교한다는 의미이다.

같은 메모리 주소를 참조하면 같다고 판단하고, 다른 메모리 주소를 참조하면 다르다고 판단하는 것.

### 2.5.2 강제 변환

**`<`, `>`, `<=`, `>=`**

비교 연산자는 타입 변환이 일어난다는 사실! 처음 알았다.

예를 들어, 문자열 값과 숫자 값을 비교하는 경우 문자열이 숫자로 타입 변환된다.

비교 연산자는 피연산자가 모두 문자열인 경우를 제외하고, 숫자로 타입변환해서 처리된다.

피연산자가 모두 문자열이라면? 알파벳순으로 비교한다.

```javascript
console.log(1 > false); // true, false가 0으로 타입변환되어서 비교
console.log(1 > "0"); // true, "0"이 0으로 타입변환되어서 비교
console.log("a" > "b"); // false, 문자열 비교
console.log("a" < "b"); // true, 문자열 비교
```

## 2.6 코드 구조화 패턴

크게 2가지 패턴이 있음

- 클래스
- 모듈

### 2.6.1 클래스

클래스는 어떠한 데이터 타입.

여기에는 데이터와, 데이터를 조작하는 동작(메서드)가 들어간다.

클래스는 값이 아니다. 실제로 프로그램에서 사용할 구체적인 값을 얻기 위해서는 `new` 키워드로 인스턴스를 생성해야함.

클래스의 의의?는, 데이터와 해당 데이터를 조작하는 로직을 묶는다는 것이다.

### 2.6.2 모듈

내가 ES6 모듈을 사용하고 있었구나!! 오랜만에 뭔가 CommonJS 등 개념들에 대해서 접하게 되었는데, 참 편하게 쓰고 있는 기능이라서 너무 마음에 들었다.

사실 이게 없으면 어떻게 개발을 할려나 싶을 정도로 잘 쓰고 있다.

처음 알게 된 사실들이 있다.

ES6 모듈에서는 `import`를 통해서 처음 모듈을 가져오는 순간 인스턴스가 생기고, 동일한 모듈을 다른 곳에서 사용하면 이미 생성된 모듈의 참조만 가져온다.!

오.. 그러면 singleton이랑 어느정도 비슷한 면이 있네.

근데 갑자기 궁금한게 생기네 그러면 React Native 앱에서 각각 JavaScript 모듈들은 처음 사용될 때 인스턴스가 생기고 유지되나?
그러면 생성된 인스턴스의 lifetime은 어떻게 되는거지?
그리고 이게 어디에 유지되는거야? 이게 Native 개발하고 차이가 있는 점은 뭐지? 이런 모듈들이 실제로 low level에서는 결국 뭐라고 생각해야되는걸까

흥미롭고만.
